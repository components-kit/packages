import { readdirSync, readFileSync, writeFileSync } from "node:fs";
import { dirname, join, resolve } from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = resolve(__dirname, "..");
const COMPONENTS_DIR = join(
  ROOT,
  "libs/react/src/components"
);
const OUTPUT_FILE = join(ROOT, "llms-full.txt");

const HEADER = `# @components-kit/react

> Headless, accessible React components styled via data attributes. Bi-directional Figma design system sync — CSS ships instantly, no code, no redeploy, no maintenance.

@components-kit/react is an unstyled React component library. All components emit \`data-*\` attributes (\`data-ck\`, \`data-variant\`, \`data-size\`, \`data-state\`, \`data-disabled\`, etc.) and are styled entirely through an external CSS bundle loaded from the ComponentsKit API.

## Installation

\`\`\`bash
npm install @components-kit/react
\`\`\`

Peer dependencies (install the ones you need):

| Dependency | Required by | Optional? |
|-----------|-------------|-----------|
| \`react\`, \`react-dom\` | All components | No |
| \`downshift\` | Select, Combobox, MultiSelect | Yes |
| \`@floating-ui/react\` | Select, Combobox, MultiSelect | Yes |
| \`@tanstack/react-table\` | Table | Yes |
| \`sonner\` | Toast | Yes |

## Core Concepts

### Headless / Data-Attribute Styling

Components have zero built-in styles. Every visual state is expressed as a data attribute:

- \`data-ck="button"\` — component identity
- \`data-variant="primary"\` — variant selection (set via \`variantName\` prop)
- \`data-size="sm" | "md" | "lg"\` — size variants
- \`data-state="selected"\` — interaction state
- \`data-disabled\` — disabled state
- \`data-loading\` — loading state

CSS is loaded from the ComponentsKit API as a single stylesheet that targets these attributes.

### The \`variantName\` Prop

Every component accepts a \`variantName\` prop that maps to \`data-variant\`. This is how you select visual variants defined in your Figma design system.

\`\`\`tsx
<Button variantName="primary">Submit</Button>
// renders: <button data-ck="button" data-variant="primary">Submit</button>
\`\`\`

### Polymorphic Components (\`as\` prop)

\`Heading\` and \`Text\` accept an \`as\` prop to render as different HTML elements:

\`\`\`tsx
<Heading as="h2" variantName="section-title">Section</Heading>
<Text as="span" variantName="caption">Small text</Text>
\`\`\`

### Composition (\`asChild\` prop)

\`Button\` and \`Badge\` support the \`asChild\` pattern via the internal \`Slot\` utility. When \`asChild\` is true, the component merges its props (refs, classNames, event handlers) onto the child element instead of rendering its own wrapper:

\`\`\`tsx
<Button asChild variantName="primary">
  <a href="/dashboard">Dashboard</a>
</Button>
// renders: <a href="/dashboard" data-ck="button" data-variant="primary">Dashboard</a>
\`\`\`

### Generic TypeScript Support

\`Select<T>\`, \`Combobox<T>\`, \`MultiSelect<T>\`, and \`Table<TData>\` are generic components for type-safe values:

\`\`\`tsx
<Select<number>
  options={[
    { value: 1, label: "One" },
    { value: 2, label: "Two" },
  ]}
  onValueChange={(val) => console.log(val)} // val is number
/>
\`\`\`

### Controlled / Uncontrolled

All interactive components support both patterns. Pass \`value\` + \`onValueChange\` for controlled, or \`defaultValue\` for uncontrolled.

### Form Integration

\`Select\`, \`Combobox\`, and \`MultiSelect\` render a hidden \`<input>\` when the \`name\` prop is provided, enabling native form submission without extra state management.

## Shared Types

### SelectOption\`<T>\`

Used by Select, Combobox, and MultiSelect:

\`\`\`typescript
type SelectOption<T = string> =
  | string                                    // simple string option
  | { value: T; label?: string; disabled?: boolean }  // labeled option
  | { type: "separator" }                     // visual separator
  | { type: "group"; label: string; options: Array<...> }  // option group
\`\`\`

### ComponentsKitVariants & VariantFor

The \`variantName\` prop accepts \`string\` by default. Run \`ck generate\` (from \`@components-kit/cli\`) to augment the \`ComponentsKitVariants\` interface with your actual variant names for autocomplete:

\`\`\`typescript
// Generated by @components-kit/cli:
declare module "@components-kit/react" {
  interface ComponentsKitVariants {
    button: "primary" | "secondary" | "outline";
  }
}
\`\`\`

### Re-exported TanStack Table Types

The Table component re-exports these types from \`@tanstack/react-table\`:
\`Cell\`, \`ColumnDef\`, \`ColumnFiltersState\`, \`ExpandedState\`, \`Row\`, \`RowSelectionState\`, \`SortingState\`

## Components Reference

Below is the full API reference for all ${readdirSync(COMPONENTS_DIR, { withFileTypes: true }).filter((d) => d.isDirectory() && d.name !== "slot").length} components.`;

// Exported components (in barrel export order, which matches the component index.ts)
const EXPORTED_COMPONENTS = [
  "alert",
  "badge",
  "button",
  "checkbox",
  "combobox",
  "heading",
  "icon",
  "input",
  "multi-select",
  "pagination",
  "progress",
  "radio-group",
  "select",
  "separator",
  "skeleton",
  "slider",
  "switch",
  "table",
  "tabs",
  "text",
  "textarea",
  "toast",
];

const sections = EXPORTED_COMPONENTS.map((name) => {
  const readmePath = join(COMPONENTS_DIR, name, "README.md");
  try {
    let content = readFileSync(readmePath, "utf-8").trim();
    // Convert first H1 to H2
    content = content.replace(/^# /, "## ");
    return content;
  } catch {
    console.warn(`Warning: No README.md found for ${name}`);
    return null;
  }
}).filter(Boolean);

// Append package READMEs (CLI, etc.) after component docs
const PACKAGE_READMES = [join(ROOT, "libs/cli/README.md")];

const packageSections = PACKAGE_READMES.map((readmePath) => {
  try {
    let content = readFileSync(readmePath, "utf-8").trim();
    content = content.replace(/^# /, "## ");
    return content;
  } catch {
    console.warn(`Warning: README not found at ${readmePath}`);
    return null;
  }
}).filter(Boolean);

const fullText = [HEADER, ...sections, ...packageSections].join(
  "\n\n---\n\n"
);

writeFileSync(OUTPUT_FILE, fullText + "\n");
console.warn(
  `Generated ${OUTPUT_FILE} (${sections.length} components, ${fullText.split("\n").length} lines)`
);
